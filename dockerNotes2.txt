==================================
DOCKER FLOW 1 : IMAGE -> CONTAINER
==================================

docker images (imageName:tag, or imageId)

Image --> docker run --> turns image into a running container, with a running process

docker run -it ubuntu:latest bash (terminal interactive)

cat /etc/lsb-release (Ubuntu distro information)

exit a running -it bash container: "exit" or Ctrl+D

docker ps (view running containers)

Image: a fixed point, where status is known, and you can always start from

==================================
DOCKER FLOW 2 : CONTAINER -> IMAGE
==================================

docker ps -a (lists all containers, including stopped)
docker ps -l (lists the last exited container)

- STATUS: Exited (0) .... exit code can be useful for diagnostics

docker commit: creates an image from a stopped container
docker image ls (docker images)

docker tag imageId my-image-name
docker image ls - will now see new iamge name under REPOSITORY

docker commit <containerName> <newImageName> --shortcut that rolls docker tag into docker commit

==================================
RUNNING THINGS IN DOCKER
==================================

docker run
- starts a container from an image, with a process
- containers have a main process.  when this process stops, the container stops

docker run --rm (delete this container when the process exits)
-skips the docker rm containerName step after a container stops

passing multiple commands to a container's bash: (semicolon separates "first do this, THEN do this")

docker run -ti ubuntu bash -c "sleep 3; echo all done"

detached containers (-d): leave them running, and let them go/continue.

docker run -d -ti ubuntu bash
(then, docker ps to see the running container - and get its ID or name)

docker attach containerId/name

ctrl-P, ctrl-Q - exits the container and leaves it running

add another process to a running container:

docker exec 
(can't add ports/volumes etc.)
good for debugging, DBA, etc

docker exec -ti runningContainerNameOrId bash - starts a bash process in a running container

==================================
MANAGE CONTAINERS
==================================

docker logs containerId/Name
(output of containers preserved)

docker kill containerName/Id - stop

docker rm containerName/Id - remove

docker run --memory maximum-allowed-memory image-name command (constrain memory resources)

docker run --cpu-shares (relative to other containers)

docker run --cpu-quota (fixed limit)

(most orchestrations require cpu limits)

** Dont let your containers fetch dependencies when they start.
- make your containers include the dependencies, inside the containers themselves.
- don't leave important things in unnamed stopped containers

==================================
CONTAINER NETWORKING
==================================

- programs in containers are isolated from internet by default
- you can group containers into "private" networks

- EXPOSE TCP PORTS TO LET CONNECTIONS IN
- specify internal port (to container) and external port

docker run --rm -ti -p 45678:45678 -p 45679:45769 --name bfost-server ubuntu bash
>> nc -lp 45678 | nc -lp 45679 (netcat)
(nc -lp = netcat listen port)

(client 1: nc localhost 45678)
>> a message

(client 2: nc localhost 45679)
>> returned: a message

using netcat with 2 clients: a message is passed into a local port, to that port on the docker conatainer, back out another port of the container, and returned at that local port on the 2nd client

host.docker.internal (used for Docker Desktop on Mac)
(client x: nc host.docker.internal port# - reference host machine port)


-p 45678:45678 vs -p 45678 ... 

docker port containerName : will show which port on local host machine container's port 45678 is mapped to

EXPOSE UDP PORTS
docker run -p 1234:1234/udp

NETWORKING BETWEEN CONTAINERS

docker network ls
-bridge: network used by containers that don't specify preference
-host: when container shouldn't have any network isolation
-none: when container should have no network

docker network create networkName

docker run --net networkName

(on server A)
nc -lp 1234

(on server B)
nc serverA 1234
> hello!

docker network connect existingServerName existingContainerName 

(can connect containers to multiple docker networks)


LEGACY LINKING

-link all ports, but only one way
-secret environment variables are shared only one way
-startup order dependent
-restarting containers may/may not break links

docker run -e ENVVARNAME=environmentVariableValue

docker run --link runningContainerName

(in linked container)
>> env
(will see linked container's env variables here in addition to container's env)


IMAGES

tagging images : give them names
docker commit tags images for you

docker commit containerName newImageName:newImageTag

(full name)
registry.example.com:port/organization/image-name:version-tag

organization/image-name is usually enough

docker pull - invoked by docker run

docker push :: 

docker rmi imageName:tagName

# TODO: write a shell script to remove docker images of type sameImageName:differentTagNames


VOLUMES

-virtual "discs" to store and share data between containers, and containers-host
-Persistent (data will remain on host after container stops)
-Ephemeral (will persist until a container is not using them)

Volumes are not part of images.  They are for local (to a host) data.

Share a folder from host to container:
docker run -v /path/to/dir/on/host:/pathWithinContainer : share a volume with a container on startup

Share a file from host to container: (must exist before the container is started)

Sharing Data between Containers:

docker run -v /my-container-dir-name --name container1

docker run --volumes-from container1 (this container will have access to the volume defined above)

Volumes created in this manner will persist past the ORIGINAL container being exited, as long as another container has inherited it by --volumes-from.  Once the last container using it is exited, the VOLUME WILL BE DELETED


DOCKER REGISTRIES

-registries manage and distribute images
-Docker the company runs registries. you can also run your own privately.

docker search imageName (docker search node, docker search ubuntu)

hub.docker.com - search images here


==================================
BUILDING DOCKER IMAGES
==================================

Dockerfile - small program that describe how to build a docker image

docker build -t name-of-container-to-build . (. = path to dockerfile, aka current directory)

-each line of a dockerfile takes image from previous line, and makes another image. previous image is unchanged
(large files shouldn't span lines - or the images will be huge)

- each step of running a Dockerfile is cached
- watching build output for "using cache" 
- docker can skip lines that weren't changed since last time Dockerfile was built
- if a line is "download big file" - it may not be re-downloaded each time. 
- *** THE PARTS THAT CHANGE THE MOST, BELONG AT THE END OF THE DOCKERFILE ***
- Dockerfiles are not shell scripts. syntax is similar.
-- processes started on one line, will not run on the next line
--- process will run in that line's container, be saved into an image, and then stop before container on next line is started
- CONTAINER PER LINE
- ENV command: environment variable set will be set on next line as well
- EACH LINE IN A DOCKERFILE IS ITS OWN CALL TO DOCKER RUN, AND ITS OWN CALL TO DOCKER COMMIT

BUILDING A DOCKERFILE

FROM : 1st line : which image to start with / where to begin
RUN : a bash command to run
CMD : set a command to run when image is started

example 1: 

FROM busybox
RUN echo "building simple docker image."
CMD echo "Hello Container"

example 2:

FROM debian:sid
RUN apt-get -y update
RUN apt-get install nano
CMD ["/bin/nano", "/tmp/notes"] aka CMD "nano" "/tmp/notes"

example 3: (debianimage was created in example 2)

FROM debianimage
ADD notes.txt /notes.txt (ADD localHostFile containerDestination)
CMD ["/bin/nano", "/notes.txt"]

FROM: which image to (possibly download) and start from
-must be first command in Dockerfile

MAINTAINER: documentation, defines author
-MAINTAINER John Doe <johndoe@gmail.com>

RUN: runs command line, waits for it to finish, saves result
-RUN unzip install.zip /opt/install
-RUN echo hello docker

ADD: adds local files, contents of tar archives (ADD automatically uncompresses tar files), and URL contents
ADD sourcePath /containerDestination
- ADD run.sh /run.sh
- ADD project.tar.gz /install/ 
- ADD https://project.example.com/download/1.0/project.rpm /project/

ENV: sets environment variables during the build AND when running the result
-ENV DB_HOST=db.production.example.com
-ENV DB_PORT=5432

ENTRYPOINT: specifies START OF command to run
- anything typed after docker run imageName would be passed as arguments to the ENTRYPOINT command

CMD: specifies ENTIRE command to run
- anything typed after docker run imageName will replace the CMD command

-if your container acts like a command-line program, you can use ENTRYPOINT
-CMD will probably be used most often.

Shell Form vs Exec Form (for ENTRYPOINT, RUN, CMD)
-shell: nano notes.txt
-exec: ["/bin/nano", "notes.txt"]

-shell form is run in a shell (duh)
-exec form causes the exec to be run directly, not surrounded in a shell like bash - SO ITS MORE EFFICIENT

EXPOSE: maps a port into the container
-EXPOSE 8080 (similar to -p docker arg)

VOLUME: defines shared (2 arg) or ephemeral (1 arg) volumes
-VOLUME ["/host/path/" "/container/path/"] - shared volume from host
-VOLUME ["/shared-data"] - ephemeral volume created on container

-generally avoid host-shared folders/files in Dockerfile. the Dockerfile will only run on your host machine!

WORKDIR: sets directory the container starts in (for remainder of Dockerfile, and for the container startup
-WORKDIR /install/

USER: sets which user the container will run as
-USER brian
-USER 1000

- USER useful for shared network volumes)













