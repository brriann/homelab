==================================
DOCKER FLOW 1 : IMAGE -> CONTAINER
==================================

docker images (imageName:tag, or imageId)

Image --> docker run --> turns image into a running container, with a running process

docker run -it ubuntu:latest bash (terminal interactive)

cat /etc/lsb-release (Ubuntu distro information)

exit a running -it bash container: "exit" or Ctrl+D

docker ps (view running containers)

Image: a fixed point, where status is known, and you can always start from

==================================
DOCKER FLOW 2 : CONTAINER -> IMAGE
==================================

docker ps -a (lists all containers, including stopped)
docker ps -l (lists the last exited container)

- STATUS: Exited (0) .... exit code can be useful for diagnostics

docker commit: creates an image from a stopped container
docker image ls (docker images)

docker tag imageId my-image-name
docker image ls - will now see new iamge name under REPOSITORY

docker commit <containerName> <newImageName> --shortcut that rolls docker tag into docker commit

==================================
RUNNING THINGS IN DOCKER
==================================

docker run
- starts a container from an image, with a process
- containers have a main process.  when this process stops, the container stops

docker run --rm (delete this container when the process exits)
-skips the docker rm containerName step after a container stops

passing multiple commands to a container's bash: (semicolon separates "first do this, THEN do this")

docker run -ti ubuntu bash -c "sleep 3; echo all done"

detached containers (-d): leave them running, and let them go/continue.

docker run -d -ti ubuntu bash
(then, docker ps to see the running container - and get its ID or name)

docker attach containerId/name

ctrl-P, ctrl-Q - exits the container and leaves it running

add another process to a running container:

docker exec 
(can't add ports/volumes etc.)
good for debugging, DBA, etc

docker exec -ti runningContainerNameOrId bash - starts a bash process in a running container

==================================
MANAGE CONTAINERS
==================================

docker logs containerId/Name
(output of containers preserved)

docker kill containerName/Id - stop

docker rm containerName/Id - remove

docker run --memory maximum-allowed-memory image-name command (constrain memory resources)

docker run --cpu-shares (relative to other containers)

docker run --cpu-quota (fixed limit)

(most orchestrations require cpu limits)

** Dont let your containers fetch dependencies when they start.
- make your containers include the dependencies, inside the containers themselves.
- don't leave important things in unnamed stopped containers

==================================
CONTAINER NETWORKING
==================================

- programs in containers are isolated from internet by default
- you can group containers into "private" networks

- EXPOSE TCP PORTS TO LET CONNECTIONS IN
- specify internal port (to container) and external port

docker run --rm -ti -p 45678:45678 -p 45679:45769 --name bfost-server ubuntu bash
>> nc -lp 45678 | nc -lp 45679 (netcat)
(nc -lp = netcat listen port)

(client 1: nc localhost 45678)
>> a message

(client 2: nc localhost 45679)
>> returned: a message

using netcat with 2 clients: a message is passed into a local port, to that port on the docker conatainer, back out another port of the container, and returned at that local port on the 2nd client

host.docker.internal (used for Docker Desktop on Mac)
(client x: nc host.docker.internal port# - reference host machine port)


-p 45678:45678 vs -p 45678 ... 

docker port containerName : will show which port on local host machine container's port 45678 is mapped to

EXPOSE UDP PORTS
docker run -p 1234:1234/udp

NETWORKING BETWEEN CONTAINERS

docker network ls
-bridge: network used by containers that don't specify preference
-host: when container shouldn't have any network isolation
-none: when container should have no network

docker network create networkName

docker run --net networkName

(on server A)
nc -lp 1234

(on server B)
nc serverA 1234
> hello!

docker network connect existingServerName existingContainerName 

(can connect containers to multiple docker networks)







